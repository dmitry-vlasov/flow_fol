import ds/tree;
import string;

export {
	FolFormula ::= FolAnd, FolOr, FolImpl, FolNot, FolQuant, FolAtomic;
		FolAnd(form1 : FolFormula, form2 : FolFormula);
		FolOr(form1 : FolFormula, form2 : FolFormula);
		FolImpl(premise : FolFormula, conclusion : FolFormula);
		FolNot(form : FolFormula);
		FolQuant(quant : FolQuantifier, form : FolFormula);

	FolAtomic ::= FolPred, FolTrue, FolFalse;
		FolPred(name : string, args : [FolTerm]);
		FolTrue();
		FolFalse();

	FolQuantifier ::= FolForall, FolExists;
		FolForall(var : FolVar);
		FolExists(var : FolVar);

	FolTerm ::= FolVar, FolFunc;
		FolVar(name : string);
		FolFunc(name : string, args : [FolTerm]);

	FolSymb ::= FolFuncSymb, FolPredSymb;
		FolFuncSymb(
			name : string,
			arity : int,
		);
		FolPredSymb(
			name : string,
			arity : int,
		);

formulaSign(f : FolFormula) -> Tree<string, FolSymb> {
	doFormulaSign(f, makeTree())
}
		
doFormulaSign(f : FolFormula, acc : Tree<string, FolSymb>) -> Tree<string, FolSymb> {
	switch (f) {
		FolAnd(f1, f2):   doFormulaSign(f1, doFormulaSign(f2, acc));
		FolOr(f1, f2):    doFormulaSign(f1, doFormulaSign(f2, acc));
		FolImpl(f1, f2):  doFormulaSign(f1, doFormulaSign(f2, acc));
		FolNot(f1):       doFormulaSign(f1, acc);
		FolQuant(q, f1):  doFormulaSign(f1, acc);
		FolPred(n, args):
			fold(args,
				setTree(acc, n, FolPredSymb(n, length(args))),
				\ac, arg -> doTermSign(arg, ac)
			);
		FolTrue(): acc;
		FolFalse(): acc;
	}
}

termSign(f : FolTerm) -> Tree<string, FolSymb> {
	doTermSign(f, makeTree())
}

doTermSign(t : FolTerm, acc : Tree<string, FolSymb>) -> Tree<string, FolSymb> {
	switch (t) {
		FolFunc(n, args): 
			fold(args, setTree(acc, n, FolFuncSymb(n, length(args))),
				\ac, arg -> doTermSign(arg, ac)
			);
		FolVar(n): acc;
	}
}

formula2string(f : FolFormula) -> string {
	switch (f) {
		FolAnd(f1, f2):  "(" + formula2string(f1) + " & " + formula2string(f2) + ")";
		FolOr(f1, f2):   "(" + formula2string(f1) + " V " + formula2string(f2) + ")";
		FolImpl(f1, f2): "(" + formula2string(f1) + " -> " + formula2string(f2) + ")";
		FolNot(f1): "-. " + formula2string(f1);
		FolQuant(q, f1):
			switch(q) {
				FolForall(v): "A" + v.name + "." + formula2string(f1);
				FolExists(v): "E" + v.name + "." + formula2string(f1);
			}
		FolPred(n, args):
			if (args == []) n else {
				n + "(" + strGlue(map(args, \arg -> term2string(arg)), ", ") + ")";
			}
		FolTrue(): "T";
		FolFalse(): "F";
	}
}

term2string(t : FolTerm) -> string {
	switch (t) {
		FolVar(n): n; 
		FolFunc(n, args): n + "(" + strGlue(map(args, \arg -> term2string(arg)), ", ") + ")";
	}
}

}
