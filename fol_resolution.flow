import fol_unify;
import fol_norm;

export {
	resolutionFOL(f : FolFormula) -> Maybe<Tree<string, FolTerm>>;
}

resolutionFOL(f : FolFormula) -> Maybe<Tree<string, FolTerm>> {
	ret = runResolution(ResolutionEnv(skolemization(toPNF(f)).cnf, makeTree(), ResolUnknown()));
	if (ret.status == ResolUnknown()) {
		None();
	} else {
		Some(ret.subst)
	}
}

ResolutionEnv(
	form : FolCNF,
	subst : Tree<string, FolTerm>,
	status : ResolStatus
);

ResolStatus ::= ResolSAT, ResolUNSAT, ResolUnknown;
	ResolSAT(); ResolUNSAT(); ResolUnknown();

contraryPairs(env : ResolutionEnv, d1 : FolDisj, ci : int, d2 : FolDisj, cj : int) -> [ResolutionEnv] {
	foldi(d1.disj, [], \di, acc, l1 ->
		foldi(d2.disj, acc, \dj, ac, l2 ->
			if (l1.atom.name == l2.atom.name && l1.sign != l2.sign) {
				switch (unifyTermArrays(l1.atom.args, l2.atom.args)) {
					Some(s): {
						concat(ac, [
							ResolutionEnv(
								applySubstToCNF(s, FolCNF(
									concat(
										filtermapi(env.form.conj, \k, d -> if (k == ci || k == cj) None() else Some(d)),
										[FolDisj(
											concat(
												filtermapi(d1.disj, \k, l -> if (k == di) None() else Some(l)),
												filtermapi(d2.disj, \k, l -> if (k == dj) None() else Some(l))
											)
										)]
									)
								)),
								composeSubst(env.subst, s),
								ResolUnknown()
							)
						])
					}
					None(): ac;
				}
			} else ac
		)
	)
}

runResolution(env : ResolutionEnv) -> ResolutionEnv {
	if (env.status != ResolUnknown()) env else {
		if (exists(env.form.conj, \d -> d.disj == [])) {
			ResolutionEnv(env with status = ResolUNSAT());
		} else {
			foldi(env.form.conj, env, \i, acc, d1 ->
				foldi(env.form.conj, acc, \j, ac, d2 -> 
					if (ac.status != ResolUnknown() || i == j) ac else {
						fold(contraryPairs(env, d1, i, d2, j), ac, \a, e ->
							runResolution(e)
						)
					}
				)
			)
		}
	}
}
